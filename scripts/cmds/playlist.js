const fs = require("fs-extra"); const axios = require("axios"); const path = require("path"); const { getStreamFromURL, shortenURL, randomString } = global.utils; const playlistPath = path.resolve(__dirname, "vs2.json"); function loadPlaylists() { if (fs.existsSync(playlistPath)) { return fs.readJsonSync(playlistPath); } return {}; } function savePlaylists(playlists) { fs.writeJsonSync(playlistPath, playlists, { spaces: 2 }); } async function downloadTrack(url) { const stream = await getStreamFromURL(url); const filePath = `${__dirname}/tmp/${randomString()}.mp3`; const writeStream = fs.createWriteStream(filePath); stream.pipe(writeStream); return new Promise((resolve, reject) => { writeStream.on('finish', () => resolve(filePath)); writeStream.on('error', reject); }); } async function getSongNameFromMedia(url) { try { const response = await axios.get(`https://yt-kshitiz.vercel.app/search?url=${encodeURIComponent(url)}`); return response.data.title || null; } catch (error) { console.error("[ERROR] Failed to fetch song name from media:", error); return null; } } module.exports = { config: { name: "playlist", version: "2.1", author: "NZ R", category: "music", dependencies: { "fs-extra": "", "axios": "" } }, onStart: async function ({ api, event, message }) { const playlists = loadPlaylists(); const userID = event.senderID; const input = event.body.trim(); const data = input.split(" "); const command = data[1]; data.splice(0, 2); if (event.messageReply && (event.messageReply.attachments.length > 0) && command === "add") { const attachment = event.messageReply.attachments[0]; if (attachment.type === "audio" || attachment.type === "video") { const mediaURL = attachment.url; const songName = await getSongNameFromMedia(mediaURL); if (!songName) { return message.reply("âŒ Couldn't extract the song name from the provided media. Please try again."); } if (!playlists[userID]) playlists[userID] = []; playlists[userID].push({ query: songName.trim() }); savePlaylists(playlists); return message.reply(`âœ… Added "${songName}" to your Spotify playlist.`); } else { return message.reply("âš  Only audio or video attachments are supported for playlist addition."); } } if (event.mentions && Object.keys(event.mentions).length > 0) { const mentionedID = Object.keys(event.mentions)[0]; const mentionedName = event.mentions[mentionedID]; if (!playlists[mentionedID] || playlists[mentionedID].length === 0) { return message.reply(`ğŸµ ${mentionedName}'s playlist is empty. Use \`playlist -s <song>\` to add songs.`); } const playlist = playlists[mentionedID]; let playlistMessage = `ğŸ¶ ${mentionedName}'s Playlist:\n`; playlist.forEach((item, index) => { playlistMessage += `\n${index + 1}. ${item.query}`; }); return message.reply(playlistMessage, (err, info) => { global.GoatBot.onReply.set(info.messageID, { commandName: "playlist", author: mentionedID, requester: userID, playlist }); }); } if (command === undefined) { if (!playlists[userID] || playlists[userID].length === 0) { return message.reply("ğŸ§ Your playlist is empty. Use `playlist add <song>` to start building your Spotify playlist ğŸ˜º"); } const playlist = playlists[userID]; let playlistMessage = "ğŸµ Your Playlist:\n"; playlist.forEach((item, index) => {
    playlistMessage += `\n${index + 1}. ${item.query}`;
});
playlistMessage += `\n\nReply by index [Number] to play your playlist's song`; return message.reply(playlistMessage, (err, info) => { global.GoatBot.onReply.set(info.messageID, { commandName: "playlist", author: userID, requester: userID, playlist }); }); } const query = data.join(" ").split(" | "); if (query.length < 1) { return message.reply("ğŸ›‘ Please provide at least one song title to add to your playlist. Use `playlist add <song>`."); } try { if (command === "add" || command === "-sing") { if (!playlists[userID]) playlists[userID] = []; query.forEach(q => playlists[userID].push({ query: q.trim() })); savePlaylists(playlists); return message.reply(`âœ… Added songs: "${query.join(", ")}" to your Spotify playlist.`); } else if (command === "-d" || command === "-delete") { const index = parseInt(query[0], 10) - 1; if (isNaN(index) || index < 0 || index >= playlists[userID].length) { return message.reply("ğŸš« Invalid index. Provide a valid number from your playlist."); } const removed = playlists[userID].splice(index, 1); savePlaylists(playlists); return message.reply(`âŒ Removed "${removed[0].query}" from your playlist.`); } else { return message.reply("â“ Unknown command. Use `playlist add <song>` to add songs or `playlist -d <number>` to delete."); } } catch (error) { console.error('[ERROR]', error); return message.reply('âš  An error occurred while processing your request. Please try again.'); } }, onReply: async function ({ api, event, Reply, message }) { if (String(event.senderID) !== String(Reply.requester)) { return; } const { playlist } = Reply; const choice = parseInt(event.body.trim(), 10); if (isNaN(choice) || choice < 1 || choice > playlist.length) { return message.reply("ğŸš« Invalid selection. Provide a number corresponding to a playlist item."); } const selected = playlist[choice - 1]; const query = selected.query; try { api.setMessageReaction("â³", event.messageID, event.messageID, api); const searchMessage = await message.reply(`ğŸ” Searching on Spotify for "${query}"...!`); const searchResponse = await axios.get(`https://spotify-play-iota.vercel.app/spotify?query=${encodeURIComponent(query)}`); const trackURLs = searchResponse.data.trackURLs; if (!trackURLs || trackURLs.length === 0) { api.unsendMessage(searchMessage.messageID); return message.reply('ğŸµ No song found for the provided query.'); } const trackURL = trackURLs[0]; const downloadResponse = await axios.get(`https://sp-dl-bice.vercel.app/spotify?id=${encodeURIComponent(trackURL)}`); const downloadLink = downloadResponse.data.download_link; const filePath = await downloadTrack(downloadLink); const replyMessage = { body: `ğŸ‰ Here is your requested song! Enjoy! ğŸ¶\n\nTitle: ${query}`, attachment: fs.createReadStream(filePath) }; api.unsendMessage(searchMessage.messageID); api.setMessageReaction("âœ…", event.messageID, event.messageID, api); message.reply(replyMessage, () => { fs.unlinkSync(filePath); }); } catch (error) { console.error('[ERROR]', error); return message.reply('âš  An error occurred while processing your request. Please try again.'); } } };